# coding: utf-8

"""
    EVR API

    OpenAPI Generator'i jaoks kohandatud EVR API kirjeldus. Kasuta seda juhul, kui spetsifikatsioonile vastava EVR API kirjeldusega ei õnnestu klienti genereerida.

    The version of the OpenAPI document: 1.14.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from typing import Optional
from pydantic import Field, StrictStr, constr
from pyevr.openapi_client.models.holding_base import HoldingBase
from pyevr.openapi_client.models.previous_owner import PreviousOwner


class ContractForTransferOfCuttingRights(HoldingBase):
    """
    ContractForTransferOfCuttingRights
    """

    contract_number: constr(strict=True, max_length=500, min_length=0) = Field(
        ..., alias="contractNumber", description="Dokumendi number"
    )
    contract_date: datetime = Field(
        ..., alias="contractDate", description="Dokumendi kuupäev"
    )
    cadaster: constr(strict=True, max_length=500, min_length=0) = Field(
        ..., description="Katastritunnus"
    )
    compartment: Optional[constr(strict=True, max_length=200)] = Field(
        None, description="Kvartal"
    )
    forest_allocation_number: Optional[StrictStr] = Field(
        None, alias="forestAllocationNumber", description="Metsaeraldis"
    )
    previous_owner: PreviousOwner = Field(..., alias="previousOwner")
    __properties = [
        "type",
        "contractNumber",
        "contractDate",
        "cadaster",
        "compartment",
        "forestAllocationNumber",
        "previousOwner",
    ]

    class Config:
        """Pydantic configuration"""

        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> ContractForTransferOfCuttingRights:
        """Create an instance of ContractForTransferOfCuttingRights from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of previous_owner
        if self.previous_owner:
            _dict["previousOwner"] = self.previous_owner.to_dict()
        # set to None if compartment (nullable) is None
        # and __fields_set__ contains the field
        if self.compartment is None and "compartment" in self.__fields_set__:
            _dict["compartment"] = None

        # set to None if forest_allocation_number (nullable) is None
        # and __fields_set__ contains the field
        if (
            self.forest_allocation_number is None
            and "forest_allocation_number" in self.__fields_set__
        ):
            _dict["forestAllocationNumber"] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> ContractForTransferOfCuttingRights:
        """Create an instance of ContractForTransferOfCuttingRights from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return ContractForTransferOfCuttingRights.parse_obj(obj)

        _obj = ContractForTransferOfCuttingRights.parse_obj(
            {
                "type": obj.get("type"),
                "contract_number": obj.get("contractNumber"),
                "contract_date": obj.get("contractDate"),
                "cadaster": obj.get("cadaster"),
                "compartment": obj.get("compartment"),
                "forest_allocation_number": obj.get("forestAllocationNumber"),
                "previous_owner": PreviousOwner.from_dict(obj.get("previousOwner"))
                if obj.get("previousOwner") is not None
                else None,
            }
        )
        return _obj
